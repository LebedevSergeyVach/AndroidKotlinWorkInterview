# Retrofit
<a name="up"></a>

---

**Retrofit** — это библиотека для работы с `HTTP`-запросами, разработанная компанией `Square`. Она позволяет:

- Описывать `API` с помощью интерфейсов.
- Выполнять синхронные и асинхронные запросы.
- Преобразовывать `JSON`-ответы в объекты `Kotlin`/`Java`.
- Работать с различными типами данных (например, `JSON`, `XML`, `Protobuf`).

---

## Основные компоненты Retrofit

### Retrofit
**Retrofit** — это основной класс, который создает реализацию `API` на основе интерфейса. 
Он настраивается с помощью **`Retrofit.Builder`**.

```kotlin
@Singleton
@Provides
fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit =
    Retrofit.Builder()
        .client(okHttpClient)
        .baseUrl(BuildConfig.URL_SERVER)
        .addConverterFactory(json.asConverterFactory(JSON_TYPE))
        .build()
```

- **baseUrl** - Базовый URL для всех запросов.
- **addConverterFactory** - Добавляет конвертер для преобразования JSON в объекты (например, `Gson`).

### Интерфейс API

**Интерфейс API** описывает методы для выполнения запросов. 
Каждый метод аннотируется для указания типа запроса (`GET`, `POST` и т.д.), пути и параметров.

```kotlin
interface ApiService {
    @GET("users/{id}")
    suspend fun getUser(@Path("id") id: Long): User

    @POST("users")
    suspend fun createUser(@Body user: User): Response<User>

    @GET("users")
    suspend fun getUsers(@Query("page") page: Int): List<User>


    @Multipart
    @POST("api/users/registration")
    suspend fun register(
        @Query("login") login: String,
        @Query("pass") password: String,
        @Query("name") name: String,
        @Part file: MultipartBody.Part,
    ): AuthData
}
```

- **@GET, @POST** - Указывают тип `HTTP`-запроса.
- **@Path** - Заменяет часть `URL` на значение параметра.
- **@Body** - Передает объект в теле запроса.
- **@Query** - Добавляет параметры запроса в `URL`.

### Converter

**Converter** — это компонент, который преобразует данные между форматами (например, `JSON` в объекты `Kotlin`/`Java`).
`Retrofit` поддерживает различные конвертеры:

- **Gson** - Для работы с `JSON`.
- **Moshi** - Альтернатива `Gson`.
- **Jackson** - Еще одна библиотека для работы с `JSON`.
- **Scalars** - Для работы с примитивными типами (например, `String`).

### CallAdapter

**CallAdapter** — это компонент, который адаптирует результат запроса к определенному типу (например, `Call`, `LiveData`, `Flow`). 
`Retrofit` поддерживает:

- **Call** - Для синхронных и асинхронных запросов.
- **LiveData** - Для интеграции с **`Android Architecture Components`**.
- **Flow** - Для работы с **`Kotlin Coroutines`**.

---

## Обработка HTTP-ошибок

`Retrofit` возвращает объект `Response`, который содержит код статуса и тело ответа.
Можно проверить, был ли запрос успешным, с помощью **`response.isSuccessful`**.

---

### Interceptors

`Retrofit` поддерживает **Interceptors**, которые позволяют перехватывать и модифицировать запросы и ответы. Это полезно для:

- Логирования.
- Добавления заголовков.
- Обработки ошибок.


---

## Callback для Retrofit

**Callback** — это механизм для обработки асинхронных запросов в `Retrofit`. 
Он позволяет выполнить код после завершения запроса, не блокируя основной поток.

Когда выполняется асинхронный запрос с помощью `Retrofit`, передается объект, реализующий интерфейс `Callback`. Этот объект содержит два метода:

- **onResponse** - Вызывается, если запрос выполнен успешно.
- **onFailure** - Вызывается, если запрос завершился с ошибкой.
- **call.enqueue** - Запускает асинхронный запрос.

---

## Coroutines для Retrofit

**Coroutines** — это механизм для написания асинхронного кода в синхронном стиле. 
Они позволяют избежать `callback hell` и упрощают обработку асинхронных операций.

`Retrofit` поддерживает **Coroutines** через интерфейс `suspend`. 
Методы, помеченные как `suspend`, могут быть вызваны из корутины и автоматически выполняются в фоновом потоке.

- **suspend fun** - Метод, который может быть приостановлен и возобновлен.
- **lifecycleScope.launch** - Запускает корутину в контексте жизненного цикла (например, `Activity` или `Fragment`).
- **try-catch** - Обрабатывает исключения (например, сетевые ошибки).

---

## Proxy

**Proxy** — это объект, который выступает в качестве заместителя другого объекта. 
Он перехватывает вызовы методов и может выполнять дополнительные действия (например, логирование, кэширование).

### Типы Proxy

**Статический Proxy**:

- Создается вручную.
- Требует написания отдельного класса для каждого проксируемого объекта.

**Динамический Proxy**:

- Создается во время выполнения.
- Использует рефлексию для перехвата вызовов методов.

### Использование Proxy в Retrofit

`Retrofit` использует динамические прокси для создания реализации интерфейса `API`. 
Когда вы вызываете метод интерфейса, `Retrofit` перехватывает вызов и выполняет `HTTP`-запрос.

В `Retrofit` ничего не генерируется, а создаётся во время выполнения кода.
Данный механизм называется `Proxy`.
У `Proxy` есть только 1 функция - `invoke`. При вызове `retrofit` разбирает все аргументы.

###  Как это работает?

- **Создание Proxy** - `Retrofit` создает динамический прокси для интерфейса `API`.
- **Перехват вызовов** - Когда вы вызываете метод интерфейса, прокси перехватывает вызов.
- **Выполнение запроса** - `Retrofit` преобразует вызов метода в `HTTP`-запрос и выполняет его.

---

- **Retrofit** — это мощная библиотека для работы с сетевыми запросами.
- **Интерфейс** **API** описывает методы для выполнения запросов.
- **Converter** преобразует `JSON` в объекты.
- **CallAdapter** адаптирует результат запроса к определенному типу.
- **Interceptors** позволяют перехватывать и модифицировать запросы и ответы.
- **Coroutines** упрощают асинхронную работу.

---

#### [README](README.md) [UP](#up)
